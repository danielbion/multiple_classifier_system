particle$type = 1
particle$best$type = 1
social = config$c2 * runif(1) * (lbest[[particle$swarm]]$pos - particle$pos)
}
particle$vel = (config$inertia * particle$vel) + personal + social
particle$vel = apply(as.matrix(particle$vel), 1, function(x){min(x,config$max_vel)})
particle$vel = apply(as.matrix(particle$vel), 1, function(x){max(x,-config$max_vel)})
particle$pos = particle$pos + particle$vel
for(i in 1:config$dim){
particle$pos[i] = min(particle$pos[i], config$upper[i])
particle$pos[i] = max(particle$pos[i], config$lower[i])
}
val = config$fun(particle$pos);
if(val < particle$best$val){
particle$best$pos = particle$pos
particle$best$val = val
}
return (particle)
}
push = function(arr, element){
len = length(arr)
arr[[len + 1]] = element
return(arr)
}
savePng = function(){
return (config$savePng && config$dim == 2)
}
# Main loop
particles = list()
p = 0
# Init particles with random position and velocity
for(swarmIndex in 1:config$sub_swarms){
for(j in 1:config$swarm_size){
pos = c()
for(i in 1:config$dim){
pos[i] = runif(1) * (config$limitUpper[[swarmIndex]][i] - config$limitLower[[swarmIndex]][i]) + config$limitLower[[swarmIndex]][i]
}
vel = rep(0, config$dim)
particles = push(particles, newParticle(pos, vel, swarmIndex, config$fun))
}
}
# Calculate initial best particles
best = calculateBest(particles);
gbest = best[[1]]
lbest = best[[2]]
unitedLbest = best[[3]]
cost = c()
for(it in 1:config$iterations){
# Update p
p = it / config$iterations
if(savePng()){
name = paste(config$savePngPath, "pso-dls-", it, ".png", sep="")
png(filename=name)
plot("", ylim=c(config$lower[2],config$upper[2]), xlim=c(config$lower[1],config$upper[2]))
}
# Update particle positions
for(i in 1:length(particles)){
particles[[i]] = updatePos(particles[[i]], p, lbest, unitedLbest)
if(savePng()){
points(particles[[i]]$pos[1], particles[[i]]$pos[2], ylim=c(config$lower[2],config$upper[2]), xlim=c(config$lower[1],config$upper[1]), col = c("green", "red", "blue", "cyan")[particles[[i]]$swarm], pch=c(1,4)[particles[[i]]$type])
}
}
# Update gbest, lbest, unitedLbest
best = calculateBest(particles);
gbest = best[[1]]
lbest = best[[2]]
unitedLbest = best[[3]]
if(savePng()){
for(i in 1:config$sub_swarms){
points(lbest[[i]]$pos[1], lbest[[i]]$pos[2], ylim=c(config$lower[2],config$upper[2]), xlim=c(config$lower[1],config$upper[1]), cex = 2, lwd = 2, col= c("green", "red", "blue", "cyan")[i], pch=c(1,4)[lbest[[i]]$type])
}
points(unitedLbest$pos[1], unitedLbest$pos[2], ylim=c(config$lower[2],config$upper[2]), xlim=c(config$lower[1],config$upper[1]), lwd = 3, col="orange", pch=23)
dev.off()
}
cost = c(cost,gbest$val)
}
if(savePng()){
name = paste(config$savePngPath, "pso-dls-0.png", sep="")
png(filename=name)
plot(cost, type = "s")
dev.off()
}
return (gbest)
}
config = c()
config$dim = 2
config$lower = c(-100, -100)
config$upper = c(100, 100)
config$fun = function(x){
return(20 + (x[1] ^ 2) - cos(10 * pi * x[1]) + (x[2]^2) + (10*cos(2 * pi * x[2])))
}
config$swarm_size = 10
config$c1 = 2.05
config$c2 = 2.05
config$max_vel = 1
config$inertia = 0.9
config$iterations = 100
config$sub_swarms = 4
config$limitLower = list(c(-50, -50), c(0, 20), c(50, -100), c(50, 50))
config$limitUpper = list(c(0, 0), c(50, 100), c(100, -50), c(100, 100))
config$savePng = TRUE
config$savePngPath = "C:/Projects/pso/pso/plot/"
PSO_DLS(config)
iris
plot(iris)
plot(iris[,1:2])
plot(iris[,1:3])
plot(iris[,2:3])
plot(iris[,1:2])
plot(iris[,3:4])
plot(iris[,c(1,3)])
plot(iris[,c(1,4)])
plot(iris[,c(1,2)])
plot(iris[,c(2,3)])
plot(iris[,c(2,2)])
plot(iris[,c(2,4)])
plot(iris[,c(3,4)])
plot(log(iris[,c(3,4)])
plot(log(iris[,c(3,4)]))
plot(iris[,c(3,4)])
plot(log(iris[,c(3,4)]))
plot(iris[,c(3,4)])
plot(log(iris[,c(3,4)]))
plot(iris[,c(1,4)])
plot(log(iris[,c(1,4)]))
plot(iris[,c(1,2)])
plot(log(iris[,c(1,2)]))
plot(log(iris[,c(3,4)]))
plot(log(iris[,c(1,2)]))
plot(log(iris[,c(1,3)]))
plot(iris[,c(1,3)])
plot(log(iris[,c(1,3)]))
plot(iris[,c(1,3)])
matrix(2,2, c(1,2), c(3,4))
matrix(2,2, c(1,2,3,4))
matrix
matrix(c(1,2,3,4)2,2)
matrix(c(1,2,3,4),2,2)
cos(0)
cos(15)
cos
cos(1)
cos(90)
cos(90/pi)
cos(90 * pi / 180)
cos(0 * pi / 180)
cos(1 * pi / 180)
cos(2 * pi / 180)
cos(20 * pi / 180)
cos(30 * pi / 180)
cos(45 * pi / 180)
cos(90 * pi / 180)
cos(91 * pi / 180)
cos(89 * pi / 180)
cos(180 * pi / 180)
rad
cos(360 * pi / 180)
rot = matrix(c(cos(15 * pi / 180),sin(15 * pi / 180),-sin(15 * pi / 180),cos(15 * pi / 180)),2,2)
plot(iris[,c(1,3)] %*% rot)
iris[,c(1,3)] %*% rot
iris[,c(1,3)] * rot
plot(iris[,c(1,3)] * ot)
plot(iris[,c(1,3)] * rot)
plot(iris[,c(1,3)])
plot(iris[,c(1,3)] * -rot)
plot(iris[,c(1,3)] * rot)
plot(iris[,c(1,3)])
plot(iris[,c(1,3)] * rot)
plot(iris[,c(1,3)])
plot(iris[,c(1,3)] * rot)
plot(iris[,c(1,3)])
rot %*% iris[c,(1,3)]
rot %*% iris[,c(1,3)]
rot
iris[,c(1,3)]
as.matrix(iris[,c(1,3)])
rot %*% as.matrix(iris[,c(1,3)])
as.matrix(iris[,c(1,3)]) %*% rot
x = as.matrix(iris[,c(1,3)])
rotate = function(x, degree){
rot = matrix(c(cos(deg2rad(degree)),sin(deg2rad(degree)),-sin(deg2rad(degree)),cos(deg2rad(degree))),2,2)
return (x %*% rot)
}
deg2rad = function(deg) {(deg * pi) / (180)}
plot(rotate(x, 1))
plot(rotate(x, 10))
plot(rotate(x, 15))
plot(rotate(x, 20))
plot(rotate(x, 45))
plot(rotate(x, 0))
plot(rotate(x, 90))
plot(rotate(x, 180))
plot(rotate(x, 5))
plot(rotate(x, 15))
plot(rotate(x, 25))
plot(rotate(x, 35))
plot(rotate(x, 45))
plot(rotate(x, 55))
plot(rotate(x, 65))
plot(rotate(x, 0))
plot(rotate(x, 50))
plot(rotate(x, 0))
x = as.matrix(iris[,c(1,3)])
rotate = function(x, degree){
rot = matrix(c(cos(deg2rad(degree)),sin(deg2rad(degree)),-sin(deg2rad(degree)),cos(deg2rad(degree))),2,2)
return (x * rot)
}
deg2rad = function(deg) {(deg * pi) / (180)}
plot(rotate(x, 1))
x = iris[,c(1,3)]
rotate = function(x, degree){
rot = matrix(c(cos(deg2rad(degree)),sin(deg2rad(degree)),-sin(deg2rad(degree)),cos(deg2rad(degree))),2,2)
return (x * rot)
}
deg2rad = function(deg) {(deg * pi) / (180)}
plot(rotate(x, 1))
plot(rotate(x, 45))
plot(rotate(x, 30))
plot(rotate(x, 15))
plot(rotate(x, 0))
plot(rotate(x, 1))
plot(rotate(x, 2))
plot(rotate(x, 3))
plot(rotate(x, 15))
plot(rotate(x, 25))
plot(rotate(x, 35))
plot(rotate(x, 45))
plot(rotate(x, 55))
plot(rotate(x, 65))
plot(rotate(x, 75))
plot(rotate(x, 85))
plot(rotate(x, 95))
plot(rotate(x, 120))
plot(rotate(x, 121))
plot(rotate(x, 122))
plot(rotate(x, 150))
plot(rotate(x, 180))
plot(rotate(x, 360))
x = as.matrix(iris[,c(1,3)])
rotate = function(x, degree){
rot = matrix(c(cos(deg2rad(degree)),sin(deg2rad(degree)),-sin(deg2rad(degree)),cos(deg2rad(degree))),2,2)
return (x %*% rot)
}
deg2rad = function(deg) {(deg * pi) / (180)}
plot(rotate(x, 1))
x = as.matrix(iris[,c(1,3)])
rotate = function(x, degree){
rot = matrix(c(cos(deg2rad(degree)),sin(deg2rad(degree)),-sin(deg2rad(degree)),cos(deg2rad(degree))),2,2)
return (x %*% rot)
}
deg2rad = function(deg) {(deg * pi) / (180)}
plot(rotate(x, 10))
x = as.matrix(iris[,c(1,3)])
rotate = function(x, degree){
rot = matrix(c(cos(deg2rad(degree)),sin(deg2rad(degree)),-sin(deg2rad(degree)),cos(deg2rad(degree))),2,2)
return (x %*% rot)
}
deg2rad = function(deg) {(deg * pi) / (180)}
plot(rotate(x, 20))
x = as.matrix(iris[,c(1,3)])
rotate = function(x, degree){
rot = matrix(c(cos(deg2rad(degree)),sin(deg2rad(degree)),-sin(deg2rad(degree)),cos(deg2rad(degree))),2,2)
return (x %*% rot)
}
deg2rad = function(deg) {(deg * pi) / (180)}
plot(rotate(x, 30))
x = as.matrix(iris[,c(1,3)])
rotate = function(x, degree){
rot = matrix(c(cos(deg2rad(degree)),sin(deg2rad(degree)),-sin(deg2rad(degree)),cos(deg2rad(degree))),2,2)
return (x %*% rot)
}
deg2rad = function(deg) {(deg * pi) / (180)}
plot(rotate(x, 40))
x = as.matrix(iris[,c(1,3)])
rotate = function(x, degree){
rot = matrix(c(cos(deg2rad(degree)),sin(deg2rad(degree)),-sin(deg2rad(degree)),cos(deg2rad(degree))),2,2)
return (x %*% rot)
}
deg2rad = function(deg) {(deg * pi) / (180)}
plot(rotate(x, 50))
x = as.matrix(iris[,c(1,3)])
rotate = function(x, degree){
rot = matrix(c(cos(deg2rad(degree)),sin(deg2rad(degree)),-sin(deg2rad(degree)),cos(deg2rad(degree))),2,2)
return (x %*% rot)
}
deg2rad = function(deg) {(deg * pi) / (180)}
plot(rotate(x, 66))
x = as.matrix(iris[,c(1,3)])
rotate = function(x, degree){
rot = matrix(c(cos(deg2rad(degree)),sin(deg2rad(degree)),-sin(deg2rad(degree)),cos(deg2rad(degree))),2,2)
return (x %*% rot)
}
deg2rad = function(deg) {(deg * pi) / (180)}
plot(rotate(x, 77))
x = as.matrix(iris[,c(1,3)])
rotate = function(x, degree){
rot = matrix(c(cos(deg2rad(degree)),sin(deg2rad(degree)),-sin(deg2rad(degree)),cos(deg2rad(degree))),2,2)
return (x %*% rot)
}
deg2rad = function(deg) {(deg * pi) / (180)}
plot(rotate(x, 88))
x = as.matrix(iris[,c(1,3)])
rotate = function(x, degree){
rot = matrix(c(cos(deg2rad(degree)),sin(deg2rad(degree)),-sin(deg2rad(degree)),cos(deg2rad(degree))),2,2)
return (x %*% rot)
}
deg2rad = function(deg) {(deg * pi) / (180)}
plot(rotate(x, 90))
x = as.matrix(iris[,c(1,3)])
rotate = function(x, degree){
rot = matrix(c(cos(deg2rad(degree)),sin(deg2rad(degree)),-sin(deg2rad(degree)),cos(deg2rad(degree))),2,2)
return (x %*% rot)
}
deg2rad = function(deg) {(deg * pi) / (180)}
plot(rotate(x, 0))
matrix(1, 2, 2)
solve(matrix(1, 2, 2))
solve(matrix(2, 2, 2))
solve(matrix(2, 2, 1))
a = matrix(c(1,2,2,1), 2, 2)
a
solve(a)
solve(1)
solve(10)
solve(100)
a = matrix(0, 2, 2)
a
b = a
c = cbind(a,b)
c
d[[1]] = 2
m = function(mu, v, M){
det(M %*% Exp(mu, v))
}
kernel = function(x1, x2, sigma){
summ = 0
for(i in 1:D){
summ = summ + (x1 - x2)^2
}
return ( exp(-sum / ((2 * sigma)^2) ))
}
Exp = function(){
}
Log = function(){
}
library('MASS')
x = as.matrix(iris[,c(1,3)]) #150 x 2
mu = mean(x) # Média estimada
cov = cov(x) # Matriz de covariância estimada
t = 0
S = dim(x)[1] # Numero de observações
D = dim(x)[2] # Numero of atributos
Z = sqrt(((2*pi)^D) * det(cov)) # Constante de normalização da distribuição normal Euclidiana
# Equação 7
sigma = 0.5
p = 0.01
M = list()
w = matrix(0, S, S)
M
w
for(i in 1:S){
for(j in 1:S){
w[i, j] = kernel(x[i,], x[j,], sigma)
}
}
i = 1
j = 1
kernel(x[i,], x[j,], sigma)
dim(x)
kernel = function(x1, x2, sigma){
summ = 0
for(i in 1:dim(x1)[2]){
summ = summ + (x1 - x2)^2
}
return ( exp(-sum / ((2 * sigma)^2) ))
}
kernel(x[i,], x[j,], sigma)
dim(x[i,])
x
i
x[i,]
x[2,]
length(x[1,])
length(x[1,]
kernel = function(x1, x2, sigma){
summ = 0
for(i in 1:length(x1)){
summ = summ + (x1 - x2)^2
}
return ( exp(-sum / ((2 * sigma)^2) ))
})
kernel = function(x1, x2, sigma){
summ = 0
for(i in 1:length(x1)){
summ = summ + (x1 - x2)^2
}
return ( exp(-sum / ((2 * sigma)^2) ))
}
kernel(x[i,], x[j,], sigma)
x1 = x[1,]
x2 = x[2,]
sigma = 2
summ = 0
kernel = function(x1, x2, sigma){
summ = 0
for(d in 1:length(x1)){
summ = summ + (x1[d] - x2[d])^2
}
return ( exp(-sum / ((2 * sigma)^2) ))
}
kernel(x[i,], x[j,], sigma)
kernel = function(x1, x2, sigma){
summ = 0
for(d in 1:length(x1)){
summ = summ + (x1[d] - x2[d])^2
}
return ( exp(-summ / ((2 * sigma)^2) ))
}
kernel(x[i,], x[j,], sigma)
kernel(x[i,], x[2,], sigma)
kernel(x[2,], x[2,], sigma)
kernel(x[2,], x[1,], sigma)
sigma = 0.5
p = 0.01
M = list()
w = matrix(0, S, S)
for(i in 1:S){
for(j in 1:S){
w[i, j] = kernel(x[i,], x[j,], sigma)
}
}
w
dim(w)
for(i in 1:S){
tempM = matrix(0, D, D)
for(d in 1:D){
for(j in 1:S){
tempM[d, d] = tempM[d, d] + (w[i, j] * ((x[i,d] - x[j,d])^2) + p)
}
}
M[[i]] = tempM
}
M
c(0,0)
rep(0, D)
v = mvrnorm(S, rep(0, D), cov)
v
plot(v)
plot(x)
plot(v)
plot(x)
plot(v)
mu
v
p = 0.01
M = list()
for(i in 1:S){
tempM = matrix(0, D, D)
for(d in 1:D){
for(j in 1:S){
tempM[d, d] = tempM[d, d] + (w[i, j] * ((x[i,d] - x[j,d])^2) + p)
}
}
M[[i]] = solve(tempM)
}
M
a
a[1,1] = 2
a[2,2] = 2
a
solve(a)
solve(2)
library('MASS')
x = as.matrix(iris[,c(1,3)]) #150 x 2
mu = mean(x) # Média estimada
cov = cov(x) # Matriz de covariância estimada
t = 0
S = dim(x)[1] # Numero de observações
D = dim(x)[2] # Numero of atributos
Z = sqrt(((2*pi)^D) * det(cov)) # Constante de normalização da distribuição normal Euclidiana
# Equação 7
sigma = 0.5
w = matrix(0, S, S)
for(i in 1:S){
for(j in 1:S){
w[i, j] = kernel(x[i,], x[j,], sigma)
}
}
d
a
cov
-cov
ginv(cov)
solve(cov)
n
v
v = mvrnorm(S, rep(0, D), cov) # Normal com média 0 e matriz de covariância estimada
v
2 / 2 * 2
2 / (2 * 2)
bigint <- integer(2^32 / 4)
bigint
bigint
library('rpart')
library('ROSE')
library('caret')
path = 'C:/Projects/lista1_multiple_classifier_system'
setwd(path)
source('utils.r')
dtMetrics = readRDS("dtMetrics.rds")
perceptronMetrics = readRDS("perceptronMetrics.rds")
dtMetrics
